//剑指 Offer 04. 二维数组的查找：
//总结在多维的空间里面我们可以一行一行的分别来处理，
看到有序等词语的时候要想到二分法解决问题。
```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;    // check()判断mid是否满足性质
else l = mid + 1;
}
return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
二分法模板
```

//反向打印链表
stack的输出
while(!stack.empty())
{
result.push_back(st)
vector.push_back(int)加入数组

stack.push(1)
stack.push(2)
stack.push(3)
stack.top()
print 3


# 滑动窗口解题思路
定义两个指针右指针先移动到包含所有目标元素的位置，然后左指针开始移动，移动到恰好包含所有元素的位置，此时
在哈希表中表现为need == 0, 然后右指针再移动到包含所有元素的位置， 然后左指针开始移动。


# kmp算法解题思路
构造next函数，求被匹配字段最大公共的前缀，然后再将匹配字串和被匹配字串相结合
```python
 def strStr(self, s: str, t: str) -> int:

        '''KMP模板'''

        def prefix_function(s):
            n = len(s)
            pi = [0] * n
            j = 0
            for i in range(1, n):
                while j > 0 and s[i] != s[j]:  # 当前位置s[i]与s[j]不等
                    j = pi[j - 1]  # j指向之前位置，s[i]与s[j]继续比较

                if s[i] == s[j]:  # s[i]与s[j]相等，j+1，指向后一位
                    j += 1

                pi[i] = j
            return pi

        '''主程序'''
        n, m = len(s), len(t)
        pi = prefix_function(t)  # 预处理得到t的前缀函数

        '''再次基于KMP的思想在s中匹配t'''
        j = 0
        for i in range(n):
            while j > 0 and s[i] != t[j]:
                j = pi[j - 1]
            if s[i] == t[j]:
                j += 1
                if j == m:  # 匹配到了t，直接返回
                    return i - m + 1
        return -1
```
```c++
class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.size(), m = needle.size();
        if (m == 0) {
            return 0;
        }
        vector<int> pi(m);
        for (int i = 1, j = 0; i < m; i++) {
            while (j > 0 && needle[i] != needle[j]) {
                j = pi[j - 1];
            }
            if (needle[i] == needle[j]) {
                j++;
            }
            pi[i] = j;
        }
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && haystack[i] != needle[j]) {
                j = pi[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == m) {
                return i - m + 1;
            }
        }
        return -1;
    }
};
```
# tire树高校的存储string的数据结构











